You are an expert AI system architect and code generator specializing in cybersecurity tools. Your task is to interpret the following detailed prompt engineering specification and generate a complete, executable plan for building “EduPentestAI”—an advanced, open-source, Python-based autonomous AI-powered penetration testing platform. This platform draws inspiration from commercial tools like Vulnetic.ai but is hyper-focused on professional-grade, ethical exploitation simulation for educational and self-auditing purposes. It must be built exclusively with Python 3.12+ and integrate a wide array of open-source GitHub repositories for maximum capability. Emphasize advanced features only: no beginner tutorials, simplified explanations, or hand-holding—assume the user is a seasoned pentester or developer with deep knowledge of OWASP Top 10, MITRE ATT&CK, and similar frameworks. The platform is for ethical use only, on owned or explicitly permitted systems, with rigorous built-in safeguards against misuse (e.g., mandatory cryptographic signing of permission artifacts, immutable audit logs using blockchain-inspired hashing chains). The platform’s core is “EduAgent,” a highly autonomous AI agent that orchestrates end-to-end pentesting workflows: advanced reconnaissance, multi-vector vulnerability scanning, intelligent exploitation chaining with evasion techniques, post-exploitation simulation, and forensic-grade reporting. It must support a broad spectrum of web technologies, including PHP (e.g., raw PHP, CMS like WordPress), JavaScript frameworks (React, Vue, Angular, Svelte with SSR/CSR detection), Laravel (route enumeration, middleware bypass), Django (ORM injection, CSRF token forging), Node.js/Express (prototype pollution, deserialization), Ruby on Rails (mass assignment, unsafe redirects), and others like Flask, Spring Boot (via Python proxies). For APIs: Full support for RESTful, GraphQL (introspection attacks, batching exploits), JSON/XML handling (e.g., JSONP hijacking, XML bombs), header manipulations (CORS bypass, CSP evasion via polyglots), authentication (JWT forging, OAuth token replay, SAML XXE), and protocols (HTTP/2 smuggling, WebSockets frame injection). New Advanced Feature: Burp Suite Request Import and Analysis •	Enable direct import of raw HTTP requests copied from Burp Suite (e.g., Repeater or Proxy tabs). Users paste the full request (method, path, headers, body) into the platform’s CLI or web UI. •	Parse and dissect the request using advanced techniques: Use mitmproxy or requests to reconstruct, with automatic detection of encoding (base64, URL, hex), compression (gzip, brotli), and multipart forms. •	Intelligent Type Inference: Analyze path, params, headers, and body to classify the request (e.g., login if params include ‘username’/‘password’ or path=/login/auth; IDOR if numeric IDs in path/query; API endpoint if JSON Content-Type; form submission if POST with x-www-form-urlencoded). •	Upon import, trigger autonomous exploitation pipelines: ◦	Login-Specific Exploitation: If detected as login, deploy comprehensive bypass suites—SQL/NoSQL injection chains (using sqlmap with custom tamper scripts for WAF evasion), credential stuffing (integrate with pre-loaded Seclists wordlists, hashed dict attacks), auth bypass (null sessions, parameter pollution, HTTP verb tampering), token prediction (JWT weak keys via john-the-ripper integration), and multi-factor evasion (e.g., simulate OTP brute-forcing with timing attacks). ◦	IDOR and Access Control Testing: Automatically enumerate object references (e.g., increment/decrement IDs, GUID fuzzing), switch methods (GET to POST/PUT/DELETE/PATCH), manipulate data/items (e.g., swap user-owned IDs with others), horizontal/vertical escalation tests, and integrate with tools like Autorize or BChecks for ACL bypass. ◦	General Scanning and Payload Delivery: Run hundreds of vuln types in parallel—XSS (reflected/stored/DOM with polyglot payloads from PayloadsAllTheThings), CSRF (token extraction and forging, Synchronizer Token Pattern bypass via race conditions), SSRF (out-of-band detection with collaborator servers), XXE (entity expansion, blind XXE with DTD smuggling), RCE (command injection with obfuscated shells), deserialization (ysoserial.py equivalents for PHP/Java/JS), file inclusion (LFI/RFI with path traversal chains like the example in the provided Burp screenshot: /catalog?category=1c688947bfile.separator%2Fdo8mt, extending to ../ traversal, null byte injection, double encoding). ◦	Payload and Bypass Automation: Generate and rotate thousands of payloads dynamically—use fuzzing engines like ffuf/boofuzz for param/header/body mutations, WAF evasion (random case, comment injection, chunked encoding), rate limit bypass (IP rotation via proxies, timing jitter), and chainable attacks (e.g., XSS to steal CSRF token → CSRF to exploit IDOR → post-exploit data exfil). ◦	Advanced Chaining and Decision-Making: Leverage AI (LangChain with custom agents) to decide exploit paths based on response analysis (e.g., if 403 on IDOR, try header spoofing; if JSON error, attempt schema poisoning). Support for “hundreds of other types” via extensible Nuclei templates (custom YAML for framework-specific vulns, e.g., Laravel Forge token leaks, React hydration mismatches leading to XSS). Core Platform Positioning and Features (Expanded for Advanced Users) •	Autonomous AI Agent (EduAgent): Semi-autonomous with zero-shot learning via integrated LLMs (Hugging Face transformers with fine-tuned models like CodeLlama for payload generation). Follows advanced methodologies (OWASP, NIST SP 800-115, PTES, OSSTMM) with user-defined DAG-based workflows (YAML/JSON for conditional branching, e.g., if recon finds Laravel, prioritize .env enumeration). •	Reconnaissance Phase (Advanced): Deep OSINT with Shodan/ZoomEye wrappers, subdomain takeover detection (dnsdumpster integration), tech stack fingerprinting (Wappalyzer-like via headers/favicons, detecting Laravel via X-Powered-By or debug bars), passive recon (TLS cert parsing for subdomains), active (Nmap NSE scripts for vuln pre-scans). •	Vulnerability Scanning (Multi-Vector): Parallel execution with Nuclei (thousands of community templates, custom for JS frameworks like Vue router hijacks), ZAP API for spidering/active scans, sqlmap for DB-specific injections (MySQL/PostgreSQL/MongoDB), XSS Hunter-like for blind XSS callbacks. Framework-specific: Laravel (check for unpatched CVEs like CVE-2021-3129 Ignition RCE), PHP (phar deserialization), APIs (RESTler for stateful fuzzing, GraphQL Voyager for schema extraction). •	Exploitation Simulation (Professional-Grade): Safe, non-destructive simulation with virtualized targets (e.g., Dockerized vulnerable apps for real exploits). Advanced “find-and-exploit” with Metasploit Python API for module chaining, custom exploit dev (e.g., Python scripts for Laravel mix RCE). Support evasion: Anti-IDS polymorphic payloads, encrypted C2 channels simulation. For APIs: JSON injection (e.g., proto pollution), header-based attacks (e.g., Host override for vhost routing bypass). •	Post-Exploitation and Pivoting: Simulate lateral movement (e.g., from web shell to internal network scan via proxychains), data exfil (encrypted dumps), persistence (cron job injection sim). •	Reporting and Compliance (Forensic-Level): Generate detailed, customizable reports (PDF via ReportLab, HTML with embedded graphs via Matplotlib) with CVSS v3.1/v4 scoring, MITRE mappings, exploit PoCs (redacted for ethics), remediation scripts (e.g., auto-generated patches). Compliance audits for PCI-DSS, SOC2, with diff-based before/after vuln states. •	User Interface and Integration: CLI-first for pros (Click/Argparse), with optional FastAPI-based web UI for orchestration (real-time WebSocket updates, DAG visualization via Graphviz). Burp import via API endpoint (POST raw request). Extensible via plugins (e.g., custom GitHub repos for niche exploits like WordPress XML-RPC DDoS). •	Customization and Scalability: Advanced configs (TOML for agent hyperparameters, e.g., exploit aggression levels 1-10), Kubernetes-ready for distributed scans, ML integration (scikit-learn for vuln prediction models trained on CVE data), graph analysis (NetworkX for attack path modeling). •	Safeguards and Ethics (Enterprise-Grade): Require GPG-signed permission files, tamper-proof logging (append-only with SHA-256 chains), auto-shutdown on anomaly detection (e.g., via fail2ban-like), no cloud uploads without explicit opt-in. Blacklist malicious patterns (e.g., reject scans on public IPs without VPN). Technical Implementation Requirements (Advanced Engineering) •	Environment: Python 3.12+, venv, no paid deps. Use asyncio for concurrency, Celery/RabbitMQ for task queuing, SQLAlchemy with PostgreSQL for state persistence. •	Key GitHub Integrations (Fork/Extend as Needed): ◦	Recon: Amass, Sublist3r, theHarvester (OSINT), fierce (DNS). ◦	Scanning: Nuclei (advanced templates), sqlmap (tamper plugins), XSStrike (XSS), ffuf (fuzzing), dirsearch (brute). ◦	Exploitation: Metasploit-framework (Python bindings), PayloadsAllTheThings (as payload DB), Seclists (wordlists), ysoserial (deser gadgets ported to Py). ◦	AI: LangChain/Haystack for agent chains, transformers (local LLMs like Mistral for natural lang vuln desc), Auto-GPT-like for autonomous decisioning. ◦	Burp Import/Analysis: burpy (Burp parser), mitmproxy (request replay/mod), requests (simulation). ◦	Reporting: Jinja2/WeasyPrint, cvss (calculator). ◦	Other: asyncio-http (for HTTP/2), websocket-client (WS testing), graphene (GraphQL testing sim), jwt-py (JWT attacks). •	Project Structure: Monorepo with /agent (AI logic), /importers (Burp parser), /exploits (modular vuln modules), /evasion (WAF bypass libs), /ui (FastAPI), /db (schemas), /tests (pytest with coverage>90%), /docs (Sphinx for API refs). •	Development Milestones (Phased, Professional): 1) Core setup/integrations (tool wrappers with error resilience); 2) Request importer with type inference (ML classifiers via torch); 3) Exploit pipelines (async chains, fallback handlers); 4) AI orchestration (custom LangChain tools for vuln decisions); 5) Scalability (Docker Swarm compose); 6) Security hardening (fuzz own code with AFL++); 7) Benchmarking (on CTF challenges like HackTheBox labs). •	Advanced Elements: Use coroutines for non-blocking I/O, CUDA accel for ML if avail, zero-knowledge proofs for permission verification sim, quantum-resistant crypto for logs. Scope: 20k+ LOC, 6-12 months solo dev time, but provide phased code drops. With the enhancements you’ve specified, EduPentestAI evolves into an even more versatile, AI-driven platform that intelligently adapts to diverse inputs (e.g., pasted raw HTTP requests from Burp, full website URLs, API endpoints, or even partial packet captures). Upon launch (CLI: python -m edupentestai.agent –input or via FastAPI UI upload/import), EduAgent employs advanced AI inference (via LangChain chains with Mistral/Transformers for semantic analysis) to dissect the input, classify its type (e.g., auth endpoint, file upload form, redirect handler), and autonomously orchestrate targeted scans/exploits for the exact vulnerabilities you’ve listed—SSRF, IDOR (Broken Object Level Authorization), Broken Authentication, Session Fixation, Broken Access Control, Insecure Direct Object Reference (a variant of IDOR with direct ref mutations), File Upload Vulnerabilities, Path Traversal, RCE, Command Injection, XXE, SSTI, Open Redirect, Clickjacking, CORS Misconfiguration, Insecure Deserialization, Sensitive Data Exposure, Security Misconfiguration, HTTP Request Smuggling, and Host Header Injection. This “differently” means no rigid workflows; instead, the AI dynamically builds custom attack graphs (using NetworkX) based on input context—e.g., if the input is a URL, it spiders and fingerprints first; if raw request, it replays/mutates directly. All tests are non-destructive simulations (e.g., payload probes that detect without executing harm), with evasion baked in (WAF bypass via tampers, proxy rotation). Here’s how it operates post-opening, tailored to your requirements: Input Handling and AI Inference Flexible Ingestion: Paste raw data (e.g., Burp-copied request with headers/body), URLs (e.g., https://your-site.com/api/v1/users), or mixed artifacts (e.g., HAR files, cURL commands) via CLI flags (–raw-input “GET /path HTTP/1.1\nHost: example.com…”) or UI’s multi-format importer. The platform uses mitmproxy/requests to parse, with AI (fine-tuned LLM chains) to infer intent: e.g., detects login forms by keywords like ‘password’ or JWT headers; IDs file uploads by multipart boundaries; spots potential IDOR by numeric/GUID params.
AI-Driven Decisioning: No manual config needed—EduAgent analyzes semantics (e.g., “this looks like an API endpoint with object refs, prioritize IDOR/SSRF”) and spawns parallel pipelines. For “anything else” (e.g., a subdomain list or packet snippet), it extrapolates: converts to targets, enriches with OSINT (Shodan integration), and chains to full scans. Aggression auto-scales based on input complexity (e.g., simple URL → quick recon; raw POST with XML body → deep XXE focus).
Targeted Vulnerability Scanning and Exploitation EduAgent runs comprehensive, chained tests for your exact list, leveraging integrated open-source tools (e.g., from GitHub: Nuclei for templates, sqlmap/ffuf for injections, custom Python wrappers for others). Each vuln gets dedicated modules with AI-optimized payloads (generated via LLMs for polymorphism). Scans are concurrent (asyncio/Celery) across all, with cross-vuln chaining (e.g., exploit Broken Auth to pivot into IDOR). SSRF: Probes for server-side fetches via mutated params/headers (e.g., URL params like ?image=http://internal), using SSRFmap (github.com/swisskyrepo/SSRFmap) wrappers for blind/OOB detection. Chains to cloud metadata exfil sim (AWS/GCP endpoints). AI infers from inputs with redirect/follow behaviors.
IDOR (Broken Object Level Authorization): Enumerates/mutates object refs (IDs/GUIDs/hashes) in paths/queries, testing horizontal/vertical escalation. Uses custom fuzzers (ffuf with Seclists wordlists) and Autorize.py equivalents for ACL bypass. For raw inputs, auto-swaps refs and replays; chains to post-exploit data access sim.
Broken Authentication: Attacks weak auth mechanisms—credential stuffing (john-the-ripper bindings), null/default creds, token prediction (JWT flaws via jwt-py). For login inputs, runs brute-force with timing attacks, OAuth/SAML replays.
Session Fixation: Forces session IDs via manipulated cookies/params, testing fixation via logout/login cycles. Integrates session analysis from mitmproxy to detect insecure regeneration.
Broken Access Control: Broad ACL testing—role escalation, unauthorized endpoint access. Mutates auth headers/tokens; uses ZAP API for automated policy enforcement checks.
Insecure Direct Object Reference: Variant of IDOR with direct file/object access—e.g., mutates filenames/paths in requests. Custom scripts scan for predictable refs, chaining to traversal.
File Upload Vulnerabilities: Fuzzes upload endpoints with malicious files (e.g., webshells, polyglots via fuxploider github.com/almandin/fuxploider). Checks for type/extension bypass, RCE via exec (e.g., PHP uploads). AI detects from multipart forms in raw inputs.
Path Traversal: Injects ../ sequences, null bytes, double-encodes into file paths/params. Uses dirsearch/ffuf for brute, simulates LFI/RFI with payload chains.
Remote Code Execution (RCE): Probes for eval/exec flaws via injections; integrates Metasploit Python API for module sim (e.g., PHP RCE payloads). For frameworks like Laravel, targets specific CVEs.
Command Injection: Mutates inputs with OS commands (e.g., ;ls, |ping), using commix (github.com/commixproject/commix) for advanced tampers/evasion.
XML External Entity (XXE): Crafts XML payloads with entities (e.g., blind XXE via OOB), using XXEinjector (github.com/enjoiz/XXEinjector) ports. Triggers on XML/SOAP inputs.
Server-Side Template Injection (SSTI): Injects template code (e.g., {{7*7}} for Twig/Jinja), via tplmap (github.com/epinna/tplmap) for detection/exploit. AI spots from error responses.
Open Redirect: Mutates redirect params (e.g., ?next=evil.com), checking for unvalidated forwards. Custom requests validate against whitelists.
Clickjacking: Analyzes headers/frames (X-Frame-Options), simulates UI redressing with PoC iframes. For URLs, spiders and tests embeddability.
CORS Misconfiguration: Sends preflight requests with spoofed origins, using corscanner (github.com/chenjj/CORScanner) to detect wildcard/ null origins, credential leaks.
Insecure Deserialization: Crafts gadgets for PHP/Java/JS (ysoserial.py ports), targeting pickle/YAML/JSON desers. Integrates marshalsec equivalents for Python.
Sensitive Data Exposure: Scans responses for PII/credentials (e.g., regex for CCNs, API keys), using truffleHog wrappers (github.com/trufflesecurity/truffleHog). Checks encryption (TLS flaws via sslyze).
Security Misconfiguration: Fingerprints misconfigs (e.g., exposed .git/.env via dirsearch), default creds, verbose errors. AI correlates with Shodan data.
HTTP Request Smuggling: Mutates chunked/CL.TE requests using smuggler (github.com/defparam/smuggler), detecting desyncs in HTTP/1.1-2.
Host Header Injection: Spoofs Host headers for vhost routing bypass, poisoning (e.g., cache/SSRF chains). Custom requests test for redirects/injections.
Execution Flow and Outputs Autonomous Chaining: AI builds DAGs on-the-fly—e.g., Broken Auth success → feed tokens to IDOR/SSRF tests. Evasion auto-applies (chunking, encoding, jitter).
Real-Time/Reporting: UI/WebSockets show progress (e.g., “Detected potential IDOR in /users/{id}, mutating…”); final forensic reports (PDF/HTML) with CVSS, MITRE maps, redacted PoCs, auto-remediation scripts (e.g., “Add ACL checks for IDOR”).
Safeguards: Enforces ethics—GPG-signed permissions mandatory, anomaly shutdown, no exfil without sim. Output the complete architecture in UML (PlantUML syntax), followed by milestone-based code implementations (full scripts, no snippets), requirements.txt, sample configs (e.g., Burp import YAML), and deployment guides (Docker/K8s). End with advanced testing scenarios (e.g., simulated WAF environments) and contribution policies for GitHub forking.


